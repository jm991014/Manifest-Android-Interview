# Category 0: The Android Framework

## Q) 3. What are the differences between Serializable and Parcelable

**Android**에서 `Serializable`과 `Parcelable`은 모두 `Activity`나 `Fragment` 등 **컴포넌트** 간에 데이터를 전달할 때 사용되는 메커니즘이다.  
하지만 **성능**과 **구현 방식** 측면에서 이 둘은 서로 다르게 동작한다.

### Serializable

- **Java 표준 인터페이스(Standard Interface):**  
`Serializable`은 `Java`에서 제공하는 표준 인터페이스로, 객체를 **바이트 스트림**으로 변환하여 **액티비티** 간 전달이나 **디스크**에 저장할 수 있게 해준다.
  - **바이트 스트림(Byte Stream):** `1 바이트(byte)`를 단위로 데이터를 처리하는 스트림을 의미한다.  
  주로 `이미지`, `오디오`, `영상`, `바이너리 파일` 등 `텍스트`가 아닌 데이터를 다룰 때 사용된다.  
  `Java`에서 `InputStream`, `OutputStream` 계열이 이에 해당한다.

- **리플렉션(Reflection) 기반 동작:**  
`Java`의 **리플렉션** 기능을 통해 동작하며, **런타임**에 클래스와 필드 정보를 동적으로 분석하여 **직렬화**를 수행한다.

- **성능:**  
**리플렉션**은 기본적으로 `Parcelable`에 비해 속도가 느린 편이다. 이는 **리플렉션** 자체의 처리 속도가 느릴 뿐만 아니라,
직렬화 과정에서 많은 **임시 객체**를 생성해 **메모리 오버헤드**가 증가하기 때문이다.

- **사용 사례:**  
**성능**이 크게 중요하지 않거나, **Android**에 종속되지 않은 범용 `Java` 코드에서 주로 사용된다.

### Parcelable
- **Android 전용 인터페이스:**  
`Parcelable`은 **Android**에 특화된 인터페이스로, 컴포넌트 간 고성능 `인터프로세스 통신(IPC)`을 위해 설계되었다.

- **성능:**  
**Android**를 위해 최적화 된 `Parcelable`은 **리플렉션**에 의존하지 않아 `Serializable`보다 빠르다.  
또한, 임시 객체 생성을 줄여 `가비지 컬렉션(GC)`을 최소화 한다.

- **사용 사례:**  
`Parcelable`은 **성능**이 중요한 상황에서 데이터를 전달할 때 유용하며, 특히 `프로세스 간 통신(IPC)`이나 **액티비티** 및 **서비스** 간의 데이터 전달에 적합하다.

현대 **Android** 개발에서는 `kotlin-parcelize` 플러그인을 사용하면 `Parcelable` 객체를 훨씬 간편하게 만들 수 있다.  
해당 플러그인은 필요한 `Parcelable` 구현 코드를 **자동**으로 생성해주므로, 기존의 수동 방식에 비해 훨씬 효율적인 접근 방식이다.  
클래스에 `@Parcelize` 어노테이션만 붙여주면 플러그인이 `Parcelable` 구현에 필요한 **메서드와 필드**를 자동으로 생성해준다.  
아래는 그 예시이다:

```kotlin
import kotlinx.parcelize.Parcelize
import android.os.Parcelable

@Parcelize
class User(val firstName: String, val lastName: String, val age: Int) : Parcelable
```

위처럼 작성하면 `writeToParcel` 같은 메서드를 오버라이딩하거나 `CREATOR`를 구현할 필요가 없어 **보일러플레이트 코드**를 줄이고 **코드의 가독성** 또한 높일 수 있다.

### Key Differences

| 항목 | Serializable       | Parcelable                |
|---|--------------------|---------------------------|
| **유형(Type)** | `Java` 표준 인터페이스      | **Android** 전용 인터페이스          |
| **성능(Performance)** | 더 느리고, **리플렉션** 사용 | 더 빠르고, **Android**에 최적화   |
| **가비지 생성량(Garbage Creation)** | 더 많은 가비지(객체) 생성    | 더 적은 객체 생성 (효율적)          |
| **사용 사례(Use Case)** | 일반적인 `Java` 환경에 적합 | **Android**, 특히 `IPC`에 적합 |

### 실전 질문

**Q)**
**Android**에서 `Serializable`과 `Parcelable`의 **주요 차이점**은 무엇이며, 컴포넌트 간 데이터 전달 시 왜 일반적으로 `Parcelable`이 선호되나요?

**A)**
**Android**에서는 컴포넌트 간 통신이 빈번하고 리소스가 제한적이기 때문에, 더 나은 성능을 제공하고 효율적인 `Parcelable`이 일반적으로 권장된다.

### 💡Pro Tips for Mastery: Parcel and Parcelable

`Parcel`은 **Android**에서 컴포넌트 간 고성능 `IPC`를 가능케 해주는 **컨테이너 클래스**이다.  
주로 데이터를 **마샬링(marshaling, 평탄화)** 하거나 **언마샬링(unmarshaling, 역평탄화)** 하여 `IPC` 경계를 넘어 전달할 수 있도록 한다.
- **마샬링(marshaling):** 객체나 자료 구조를 전송 가능한 형식으로 변환하는 과정을 의미한다.
**Android**에서는 주로 `IPC` 과정에 사용되며 데이터가 `Binder`와 같은 메커니즘을 통해 전송될 수 있도록 **직렬화**된다.
  - **IBinder:** **Android**에서 컴포넌트 간 데이터를 주고받을 수 있게 해주는 `IPC` 인터페이스이다.
- **언마샬링(unmarshaling):** **직렬화**된 데이터를 원래의 객체나 데이터 구조로 **복원(역직렬화)**하는 과정이다.
**Android**에서는 `IPC`를 통해 수신한 데이터가 수신 측 프로세스에서 다시 사용될 수 있도록 역직렬화된다.

`Parcel`은 **평탄화된 데이터**와 **live IBinder** 객체에 대한 참조를 함께 `IPC` 메커니즘을 통해 전달하기 위한 컨테이너이다.
해당 클래스는 고성능 `IPC` 전송을 위해 설계되었으며, `Parcelable` 인터페이스를 사용하는 객체들을 효율적으로 직렬화하고 컴포넌트 간 전달할 수 있도록 해준다.  
단, `Parcel`은 **범용 직렬화 도구**가 아니며, 내부 구현 방식이 변경될 수 있기 때문에 지속적인 데이터 저장 용도로 사용해서는 안 된다.

해당 `API`는 **원시 데이터 타입**, **배열**, **`Parcelable` 객체** 등을 읽고 쓸 수 있는 다양한 메서드를 포함하고 있어 객체가 스스로를 **직렬화**하고 필요 시 **복원(역직렬화)**할 수 있도록 해준다.  
또한, `Parcelable`을 사용할 때 클래스 정보를 기록하지 않고도 작동하는 최적화된 메서드들도 제공하는데, 이 경우 데이터를 읽는 쪽에서 타입을 사전에 알고 있어야 효율적인 처리가 가능하다.

`Parcelable`은 객체를 **직렬화**하여 `Parcel`을 통해 전달할 수 있도록 해주는 **Android** 전용 인터페이스이다.  
`Parcelable`을 구현한 객체는 `Parcel`에 기록하고 다시 복원할 수 있기 때문에, **Android** 컴포넌트 간에 복잡한 데이터를 전달할 때 적합하다.
