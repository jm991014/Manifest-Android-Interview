# Category 0: Compose Fundamentals

## Q) 2. Why is Jetpack Compose a declarative UI framework?

**Jetpack Compose**는 **선언형 UI 프레임워크**로 간주되는데, 이는 개발자가 상태에 따라 UI가 어떻게 보여야 하는지를 기술할 뿐,
상태가 바뀔 때마다 UI를 어떻게 업데이트 할 지를 일일이 작성하지 않기 때문이다.
이는 전통적인 **명령형 UI 접근 방식**과 대조된다. 명령형 방식에서는 개발자가 `뷰(View)`를 직접 조작하여 UI를 갱신하고, UI의 일관성을 스스로 유지해야 한다.

### Jetpack Compose의 선언형 UI 주요 특징

- **상태 기반 UI:**  
**선언형 UI 프레임워크**에서는 상태 관리가 프레임워크 자체에 내장되어 있다. 시스템은 각 컴포넌트의 **상태를 추적**하고, 상태가 변경되면 자동으로 **UI를 갱신**한다.
개발자는 특정 상태에 맞춰 UI가 어떻게 보여야 하는지만 정의하면 되고, 렌더링 업데이트는 프레임워크가 알아서 처리한다.
**Jetpack Compose**에서는 UI가 전적으로 상태에 의해 구동된다.
상태가 변경될 때마다 프레임워크가 `Recomposition`을 트리거하여 영향을 받는 UI 요소만 업데이트하고 최신 데이터를 반영하므로, 수동으로 뷰를 관리할 필요가 없다.
- **함수나 클래스로 컴포넌트 정의:**  
**선언형 UI 프레임워크**는 UI 요소를 모듈형 컴포넌트로 정의하는 것을 장려한다. 이 컴포넌트들은 함수나 클래스로 표현되며, UI 레이아웃과 동작을 함께 기술한다.
이를 통해 `XML` 같은 마크업 언어와 `Kotlin/Java` 같은 네이티브 언어 사이의 간극을 줄인다.
**Jetpack Compose**에서는 `@Composable` 함수를 통해 재사용 가능한 UI 컴포넌트를 정의한다.
각 함수는 현재 상태에 따라 UI를 설명하며, 다른 함수와 조합하여 모듈화되고 확장 가능한 구조를 만들 수 있다.
- **직접적 데이터 바인딩:**
**선언형 UI 프레임워크**는 모델 데이터를 UI 컴포넌트에 직접 바인딩할 수 있도록 한다.
이 덕분에 **수동 동기화**가 필요 없어지고, 더 **깔끔하고 유지보수가 쉬운** 코드를 작성할 수 있다.
**Jetpack Compose**에서는 함수의 파라미터를 통해 데이터를 바인딩한다.
이 과정에서 중간 데이터 바인딩 계층이나 복잡한 어댑터 패턴이 필요 없으므로 UI 개발이 크게 단순화된다.
- **컴포넌트의 멱등성:**
**선언형 프레임워크**의 핵심 특징 중 하나는 멱등성이다. 즉, **동일한 입력**이 주어지면 몇 번 실행되더라도 항상 **동일한 출력**을 생성한다는 의미다.
이 속성은 **일관된 동작**과 **컴포넌트 재사용성**을 보장한다.
**Jetpack Compose**에서는 모든 `@Composable` 함수가 본질적으로 멱등성을 가지며, 동일한 입력 파라미터가 주어졌을 때 항상 동일한 UI 결과를 생성하여 예측 가능하고 안정적인 UI 렌더링을 지원한다.

### Jetpack Compose vs. XML

**Jetpack Compose**는 선언형 UI 방식을 채택하여, 개발자가 상태 조건을 직접 `Kotlin` 코드 안에 포함시켜 논리적으로 UI를 작성할 수 있게 한다.
이 접근 방식은 상태 변화에 따라 UI가 자동으로 갱신되도록 보장해주며, 상태 관리와 코드 가독성을 모두 단순화한다.

```kotlin
@Composable
fun Main() {
    var count by remember { mutableStateOf(0) }
    CounterButton(count) {
        count++
    }
}
@Composable
fun CounterButton(count: Int, onClick: () -> Unit) {
    Button(onClick = onClick) {
        Text("Clicked: $count")
    }
}
```

**Jetpack Compose**가 왜 **선언형 UI 프레임워크**로 분류되는지를 그 핵심 원칙을 기준으로 나눠보면 다음과 같다:

1. **함수로 UI 정의:**  
`@Composable`로 어노테이션된 함수는 **Compose Compiler**에 의해 해석되고 변환되어 선언형 UI 생성을 가능하게 한다.
이는 선언형 UI의 첫 번째 원칙인 함수나 클래스를 통해 UI 컴포넌트를 정의한다는 점과 일치한다.
2. **상태 관리:**  
`remember` 같은 함수는 **Compose Runtime**이 제공하며, 컴포저블의 상태와 생명주기를 효율적으로 관리한다.
이는 선언형 UI의 두 번째 특징인 컴포넌트 내부의 자동 상태 관리를 충족한다.
3. **직접적 데이터 바인딩:**  
`CounterButton` 컴포저블 함수의 `count` 파라미터가 UI에 직접 바인딩되어, 데이터가 UI 컴포넌트에 매끄럽게 연결되는 방식을 보여준다.
이는 선언형 UI의 세 번째 원칙인 직접 데이터 바인딩을 충족한다.
4. **컴포넌트의 멱등성:**  
`CounterButton` 컴포저블은 동일한 입력 값에 대해 항상 동일한 UI 출력을 생성하여 예측 가능한 동작을 보장한다.
이는 선언형 UI의 네 번째 원칙인 컴포넌트의 멱등성 보장을 뒷받침한다.

```xml
<RelativeLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="horizontal"
    android:padding="4dp">
    
    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Clicked: 0" />
</RelativeLayout>
```

언뜻 보기에 `XML` 레이아웃은 선언형 UI 접근 방식과 유사해 보일 수 있다. 왜냐하면 `XML` 자체가 본질적으로 선언형이기 때문이다.
**Android**의 전통적인 레이아웃 시스템에서 개발자는 UI가 어떻게 보여야 하는지를 구조와 속성으로 기술하고, 실제 렌더링 과정은 프레임워크에 맡긴다.
이는 선언형 프로그래밍의 핵심 원칙, UI를 어떻게 렌더링할지가 아니라 무엇이 되어야 하는지를 지정하는 것과 일치한다.

핵심 차이는 **상태**와 **로직 처리 방식**에 있다.
`XML` 기반 개발에서는 UI의 구조와 속성을 `XML`에서 정의하고, 상태 관리 및 UI 업데이트는 `Java`나 `Kotlin`으로 작성된 명령형 코드에서 따로 구현해야 한다.
이러한 분리는 종종 더 복잡한 워크플로를 유발하며, UI와 애플리케이션 로직 사이에서 수동으로 동기화를 맞춰야 하는 문제를 만든다.

```kotlin
var counter = 0
    binding.button.setOnClickListener {
    counter++
    binding.button.text = counter.toString()
}
```

반면에, **Jetpack Compose**와 같은 선언형 프레임워크는 상태 관리와 UI 정의를 긴밀하게 통합하여, 상태가 변경될 때 자동으로 UI가 원활하게 업데이트되도록 한다.
또한 이 과정은 `Kotlin` 언어 자체에 자연스럽게 통합되어 있어, UI와 상태 변화에 따른 반응을 한 곳에서 정의할 수 있다.
이 방식은 코드의 응집도를 높이고, 별도의 명령형 핸들러를 작성할 필요를 제거한다. 즉, UI와 상태 기반 업데이트 로직을 분리하지 않고 함께 기술할 수 있어 더 단순하고 일관된 구조를 제공한다.

### 실전 질문

**Q)** **Jetpack Compose**의 선언형 특성은 기존의 명령형 `XML` UI 개발과 어떻게 다르며, 어떤 장점을 제공하나요?

**A)**  
차이점: 기존에는 UI 구조와 속성을 `XML`에 정의하고, 상태 변화나 이벤트에 따른 UI 업데이트는 `Kotlin`, `Java`의 명령형 코드에서 직접 관리해야 했습니다. 이로 인해 UI와 상태 관리가 분리되어 있고, 뷰와 로직을 일일이 동기화하는 부담이 있었습니다.
**Jetpack Compose**는 UI 정의와 상태 관리를 하나의 선언형 모델 안에 통합합니다. 즉, UI는 단순히 “현재 상태가 이렇다면 UI는 이렇게 보인다” 라고 선언할 뿐이고, 상태가 바뀌면 Compose가 자동으로 해당 부분만 다시 그려줍니다.

장점:  
- 코드가 간결해지고 중복이 줄어듭니다.
- 상태 변화에 따른 UI 일관성이 자동으로 보장됩니다. 
- `XML`과 `Kotlin`을 오가며 로직을 나누는 대신, 한 곳에서 UI와 상태를 함께 관리할 수 있어 응집도 높은 코드를 작성할 수 있습니다. 
- 유지보수성과 확장성이 높아지고, 복잡한 데이터 흐름을 더 직관적으로 표현할 수 있습니다.

**Q)** **Jetpack Compose**는 어떤 방식으로 컴포저블에서 멱등성을 달성하며, 왜 이것이 선언형 UI 시스템에서 중요한가요?

**Compose**의 모든 `@Composable` 함수는 같은 입력에 대해 항상 같은 출력을 만들어내도록 설계되었습니다.
이는 함수형 프로그래밍 개념과 유사하며, `SideEffect`를 최소화합니다.
**Compose 컴파일러**와 **런타임**이 이를 보장해주며, 동일한 파라미터로 여러 번 호출해도 결과 UI는 변하지 않습니다.

이를 통해 개발자는 UI 렌더링 결과를 쉽게 예상할 수 있으며 컴포저블 함수를 다른 컨텍스트에서도 안정적으로 재사용할 수 있습니다.
또한, 변경된 부분만 효율적으로 다시 그릴 수 있어 성능 최적화 면에서도 장점을 지닙니다.
